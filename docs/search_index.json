[["index.html", "Getting Started with Mapping Chapter 1 About This Guide", " Getting Started with Mapping Geospatial Cross Team 2024-03-07 Chapter 1 About This Guide Could put something in here about the cross team? This guide is an introduction to mapping using R in Posit Workbench. It covers basic geospatial terminology in Chapter 2, mapping examples in Chapter 3, required packages and setting up Posit in Chapter 4 areal unit mapping in Chapter 5, point mapping in chapter 6, and some useful resources in chapter 7. "],["introduction-to-geospatial-analysis.html", "Chapter 2 Introduction to Geospatial Analysis 2.1 Terminology 2.2 Mapping Tools", " Chapter 2 Introduction to Geospatial Analysis The term Geospatial analysis applies where we are interested in exploring data that relate to particular spatial locations. These locations may be single point locations, such as the coordinate locations of hospitals, GP practices, patients’ homes. The location may also relate to administrative regions, such as health boards, health and social care partnerships, localities, data zones. 2.1 Terminology This section will outline some of the key terminology that will be used throughout this guide. 2.1.1 Types of Spatial Data There are two commonly used types of spatial information that you are likely to encounter. These are areal unit data and spatial point data. Each of these is described below. 2.1.1.1 Areal Unit Data Areal unit data is data that relates to specific regions combined with spatial information about the regions (e.g. rate of hospital admissions per 1,000 population for each health board in Scotland along with information on the boundaries of the region). This type of spatial data is usually supported by shape files. Shape files are a set of files that contain information on a particular spatial region, particularly coordinates which represent the boundary (or, where there is a collection of regions, boundaries) of an area. Typically we would produce maps of areal unit data in two circumstances: When we are interested in comparing measurements or observations of data across a large number of regions (where the number of regions is more than should be sensibly displayed on a bar chart), Where we are interested in the spatial pattern as a whole. For the second type of analysis we might be thinking about answering questions such as: Are there clusters of areas that are close to each other that have similar observations? Are there neighbouring areas where there is a large difference in observations? Is there a general trend in observations across the surface? (This can include simple trends like increasing from south to north, but may involve more complex trends like urban vs rural areas.) 2.1.1.2 Spatial Point Data Spatial point data can be characterised in two ways depending on what our main focus is. When we talk about geostatistical data, this indicates that we are mainly interested in the observation associated with a particular point location, rather than the location itself. An example of this might be weather measurements, where the location is important in building up a picture of the weather over a space, but we are mostly interested in the level of rainfall in a particular location. Usually with this type of data we would be aiming to create a smooth estimate of the measurement across the entire area of interest - so instead of having rainfall at individual weather stations, we would get an estimate of rainfall for all locations in Scotland. When we talk about point process data, this indicates that our primary focus is on the location itself. This type of data would be considered where we are interested in the location of services, or the location of cases of a particular disease. Include John Snow Cholera example? 2.1.2 Coordinate Reference Systems Coordinate reference systems are used to represent single point locations. Two commonly used coordinate systems in the UK are: easting, northing - this is the coordinate system recommended by the UK government for representing spatial data based on the British National Grid. Since the UK is such a small area in relation to the Earth as a whole this coordinate system represents locations in the UK on a flat grid. This will usually be the coordinate system used in any shape files produced by the UK government. longitude, latitude - this coordinate system is used globally and defines a point by its distance in degrees from the central lines on the Earth. Longitude is the “x” coordinate - it is the distance from the prime meridian which cuts the Earth in half vertically. Latitude is the “y” coordinate - which is the distance from the equator, which cuts the earth in half horizontally. It is important to be aware of which coordinate reference system you are using, as some tools will only work with specific types which will lead to errors or unusual output if you use the wrong system. For use in R, we will transform our data into longitude/latitude for consistency. 2.2 Mapping Tools There are several tools that can be used to access, manipulate and map spatial data. These range from Graphical Information Systems (GIS), to programming languages such as R and Python when supported by an appropriate spatial package. Power BI also has mapping capabilities, supported by Bing. This guide will focus on how to create maps using Posit, supported by the packages {sf} and {ggplot2} for non-interactive maps, and {leaflet} for interactive mapping. Is this true? - is there anyone else who could do something similar for GIS or Power BI? "],["mapping-examples.html", "Chapter 3 Mapping Examples", " Chapter 3 Mapping Examples Need some nice examples - do we want to separate this into tools, r packages? "],["mapping-in-posit.html", "Chapter 4 Mapping in Posit 4.1 Setting up Posit", " Chapter 4 Mapping in Posit Mapping in Posit is primarily supported by the {sf} package, which allows geospatial information to be held and interpreted by R functions. Then we can produce static maps using {ggplot2}, or interactive maps using {leaflet}. This guide will give details on how to construct a basic map in leaflet, but this package is very powerful, and can do a lot more. 4.0.1 Required Packages In order to produce maps, you will need the following packages: {sf} {leaflet} {sp} {raster} {terra} For the purposes of mapping, the last three packages are used to support {leaflet} and {sf} (although they are spatial packages in their own right). Usually you do not need to load these directly. Full details on how to install these packages initially can be found on the page How to Install and Use Geospatial R Packages on the Data Science Knowledge Base. The full script that is described on this page can be found below Show Installation Code - This might be a mistake to include and happy to take opinion # Set environment variables to point to installations of geospatial libraries ---- ## Amend &#39;LD_LIBRARY_PATH&#39; ---- # Get the existing value of &#39;LD_LIBRARY_PATH&#39; old_ld_path &lt;- Sys.getenv(&quot;LD_LIBRARY_PATH&quot;) # Append paths to GDAL and PROJ to &#39;LD_LIBRARY_PATH&#39; Sys.setenv(LD_LIBRARY_PATH = paste(old_ld_path, &quot;/usr/gdal34/lib&quot;, &quot;/usr/proj81/lib&quot;, sep = &quot;:&quot;)) rm(old_ld_path) ## Specify additional proj path in which pkg-config should look for .pc files ---- Sys.setenv(&quot;PKG_CONFIG_PATH&quot; = &quot;/usr/proj81/lib/pkgconfig&quot;) ## Specify the path to GDAL data ---- Sys.setenv(&quot;GDAL_DATA&quot; = &quot;/usr/gdal34/share/gdal&quot;) # Step 1 - remove geospatial R packages and their dependencies (if installed) ---- # List of geospatial packages that will be installed geo_pkgs &lt;- c(&quot;leaflet&quot;, &quot;raster&quot;, &quot;sp&quot;, &quot;terra&quot;, &quot;sf&quot;) # List of geospatial package dependencies geo_deps &lt;- unique( unlist(tools::package_dependencies(packages = geo_pkgs, recursive = TRUE))) # Remove geospatial packages and their dependencies pkgs_to_remove &lt;- unique(unlist(c(geo_pkgs, geo_deps))) remove.packages(pkgs_to_remove) # Step 2 - Install the {parallelly} package to identify number of CPUs available ---- # Remove &#39;parallelly&#39; if it is already installed remove.packages(&quot;parallelly&quot;) # Install the &#39;parallelly&#39; package install.packages(&quot;parallelly&quot;) # Identify the number of CPUs available ncpus &lt;- as.numeric(parallelly::availableCores()) # Step 3 - Install geospatial package dependencies that can be installed as binaries ---- # Get list of geospatial package dependencies that can be installed as binaries geo_deps_bin &lt;- sort(setdiff(geo_deps, geo_pkgs)) # Remove packages that are already installed from the list of geospatial package dependencies geo_deps_bin &lt;- sort(setdiff(geo_deps_bin, as.data.frame(installed.packages())$Package)) # Install these as binaries install.packages(pkgs = geo_deps_bin, repos = c(&quot;https://ppm.publichealthscotland.org/all-r/__linux__/centos7/latest&quot;), Ncpus = ncpus) # Step 4 - Install geospatial packages from source ---- geo_config_args &lt;- c(&quot;--with-gdal-config=/usr/gdal34/bin/gdal-config&quot;, &quot;--with-proj-include=/usr/proj81/include&quot;, &quot;--with-proj-lib=/usr/proj81/lib&quot;, &quot;--with-geos-config=/usr/geos310/bin/geos-config&quot;) # Install the {sf} package install.packages(&quot;sf&quot;, configure.args = geo_config_args, INSTALL_opts = &quot;--no-test-load&quot;, repos = c(&quot;https://ppm.publichealthscotland.org/all-r/latest&quot;), Ncpus = ncpus) # Install the {terra} package install.packages(&quot;https://ppm.publichealthscotland.org/all-r/latest/src/contrib/Archive/terra/terra_1.7-29.tar.gz&quot;, repos = NULL, type = &quot;source&quot;, configure.args = geo_config_args, INSTALL_opts = &quot;--no-test-load&quot;, Ncpus = ncpus) # Install the {sp} package install.packages(&quot;sp&quot;, configure.args = geo_config_args, INSTALL_opts = &quot;--no-test-load&quot;, repos = c(&quot;https://ppm.publichealthscotland.org/all-r/latest&quot;), Ncpus = ncpus) # Install the {raster} package install.packages(&quot;https://ppm.publichealthscotland.org/all-r/latest/src/contrib/Archive/raster/raster_2.5-8.tar.gz&quot;, repos = NULL, type = &quot;source&quot;, configure.args = geo_config_args, INSTALL_opts = &quot;--no-test-load&quot;, Ncpus = ncpus) # Install the {leaflet} package install.packages(&quot;leaflet&quot;, repos = c(&quot;https://ppm.publichealthscotland.org/all-r/__linux__/centos7/latest&quot;), type = &quot;source&quot;, dependencies = FALSE, configure.args = geo_config_args, INSTALL_opts = &quot;--no-test-load&quot;, Ncpus = ncpus) # Step 5 - Load packages ---- dyn.load(&quot;/usr/gdal34/lib/libgdal.so&quot;) dyn.load(&quot;/usr/geos310/lib64/libgeos_c.so&quot;, local = FALSE) library(sf) library(leaflet) 4.1 Setting up Posit Any time you are doing work with any of these spatial packages, in a new session, you will need to run code to set the environment variables and load the geospatial libraries. You can do this using the code below (which is a subset of the code used to install the spatial packages!) Show Initialisation Code # Set environment variables to point to installations of geospatial libraries ---- ## Amend &#39;LD_LIBRARY_PATH&#39; ---- # Get the existing value of &#39;LD_LIBRARY_PATH&#39; old_ld_path &lt;- Sys.getenv(&quot;LD_LIBRARY_PATH&quot;) # Append paths to GDAL and PROJ to &#39;LD_LIBRARY_PATH&#39; Sys.setenv(LD_LIBRARY_PATH = paste(old_ld_path, &quot;/usr/gdal34/lib&quot;, &quot;/usr/proj81/lib&quot;, sep = &quot;:&quot;)) rm(old_ld_path) ## Specify additional proj path in which pkg-config should look for .pc files ---- Sys.setenv(&quot;PKG_CONFIG_PATH&quot; = &quot;/usr/proj81/lib/pkgconfig&quot;) ## Specify the path to GDAL data ---- Sys.setenv(&quot;GDAL_DATA&quot; = &quot;/usr/gdal34/share/gdal&quot;) # Load geospatial libraries dyn.load(&quot;/usr/gdal34/lib/libgdal.so&quot;) dyn.load(&quot;/usr/geos310/lib64/libgeos_c.so&quot;, local = FALSE) This code can be saved in a network location and loaded each time using the function source(). Alternatively you can edit your .Rprofile file to include the code so that it automatically runs this code when you open a session on Posit. You can edit your user wide .Rprofile file, which will apply to all of your Posit sessions by running the following: # install the {usethis} package if you haven&#39;t already # install.packages(&quot;usethis&quot;) usethis::edit_r_profile() This will open a script window where you can copy and paste the set up code. Note that if you use projects and set up a .Rprofile for your project specifically, you will also need to include the code in that file if you are doing something spatial. If you don’t run this code prior to loading spatial packages, your Posit session will abort. "],["areal-unit-data-1.html", "Chapter 5 Areal Unit Data 5.1 Reading in Shapefiles 5.2 Joining with data 5.3 {ggplot2} 5.4 {leaflet}", " Chapter 5 Areal Unit Data This section will focus on mapping areal unit variable, where we have a variable of interest that we want to display for each region of interest. For this section we will look at building a map of SIMD quintile across the Lothian Health Board. In order to do this we will need to: Read in the spatial information using the function read_sf() from the {sf} package Read in the data that we want to plot using the {readr} package (or a relevant package for reading in your data file) Join with a standard data set, and filter using functions from the {dplyr} package Produce maps using either the {ggplot2} package, or the {leaflet} package We’ll start by loading all of these packages - remember if you are only using {ggplot2} you don’t need to load {leaflet} and similarly if you are only using {leaflet} you don’t need to load {ggplot2}. library(sf) # reading in the spatial information library(readr) # reading in data (this may change depending on file type) library(dplyr) # manipulating the data library(ggplot2) # plotting a static map library(leaflet) # plotting an interactive map 5.1 Reading in Shapefiles The spatial information about the regions that you are trying to plot is contained within the shape files. This is a collection of files all with the same name and different file extensions that contain information on the regions, and how they should be plotted. For R you only need three of these files with the extensions .shp, .dbf, and .shx. Each of these serves a particular function: The .shp file (shape file) contains information on the boundaries of the regions. Specifically this is a collection of sets of coordinates that make up the boundary. The .dbf file (database file) contains data that relate to the boundaries. This can include multiple different variables, but at a minimum must contain a column with region IDs. Usually this file will also contain information on things like the region areas, though these typically are not used. The .shx file (shape index file) contains indexing information that allows the information in the shape file to be linked to the data in the database file. It also has implications on plotting order (though this usually isn’t particularly important). Since these files are all linked, they are read in together using the function read_sf(), where the only argument is the file path for the .shp file. The code below reads in information on data zone boundaries and names the resulting object spat: path &lt;- &quot;/conf/linkage/output/lookups/Unicode/Geography/Shapefiles/Data Zones 2011/&quot; spat &lt;- read_sf(paste0(path, &quot;SG_DataZone_Bdry_2011.shp&quot;)) When you read this in, you should notice that it appears to be exactly the same as any other data frame in R. It pretty much is, which means that you can join, and filter and manipulate the data in spat in exactly the same way as any other data frame. The thing that makes spat spatial is that is has a special column called GEOMETRY which contains objects that are POLYGON or MULTIPOLYGON types defining the region associated with each observation. 5.2 Joining with data The next step is to read in the SIMD information - this step is exactly the same as it normally would be. The information in this case is stored in a .rds file, so we will make use of the function read_rds() from the readr package. The column Datazone2011 is being renamed to DataZone to match the column name in the spatial information. data_path &lt;- &quot;/conf/linkage/output/lookups/Unicode/Deprivation/&quot; SIMD &lt;- read_rds(paste0(data_path, &quot;DataZone2011_domain_level_simd.rds&quot;)) %&gt;% rename(DataZone = Datazone2011) Now that we have all of the information required to map, we need to join the two data sets. We do this in the usual way using one of the join functions from {dplyr}. One important note here is that the object containing the spatial information must be the first argument in your join function, if it isn’t your resulting data will not have spatial characteristics: class(left_join(SIMD, spat)) ## [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; class(left_join(spat, SIMD)) ## [1] &quot;sf&quot; &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; You can see that the class of the combination of SIMD and spat does not have the characteristic sf while the class of the combination spat and SIMD retains this characteristic. Since we are only interested in plotting over regions in the Lothian health board, we should also filter these out. We can do this as usual using the filter() function from {dplyr}. So obtaining our joined and filtered data set as follows: SIMD_map &lt;- spat %&gt;% left_join(SIMD) %&gt;% filter(hb2019name == &quot;NHS Lothian&quot;) Now that we have the data joined and filtered appropriately, we can start producing maps. 5.3 {ggplot2} To produce a map in ggplot2 with any spatial data (including point data) we use the geometry function geom_sf(), within which we can specify aesthetics like fill and colour to represent observations. So, to map SIMD quintile, which is represented by the column simd202_11: ggplot(SIMD_map) + geom_sf(aes(fill = simd202_11)) This is fine, but we can customise it a bit more by changing the colour scale, and naming the fill scale more appropriately. To help to visualise the small regions, I’ll also set the border colour to be set according to SIMD. Maps also usually look nicer when they are presented using theme_void() (although this is up to your own personal preference!): ggplot(SIMD_map) + geom_sf(aes(fill = simd202_11, colour = simd202_11)) + scale_fill_viridis_c(&quot;SIMD Quintile&quot;, option = &quot;C&quot;, aesthetics = c(&quot;fill&quot;, &quot;colour&quot;)) + theme_void() Although this map is static, we can use ggplotly() to introduce a small amount of interactivity. The column has been renamed to improve the labels, and tooltip has been specified to reduce duplication. There is also a dummy aesthetic DZ which allows us to show the data zone name: p &lt;- SIMD_map %&gt;% rename(`SIMD Quintile` = simd202_11) %&gt;% ggplot() + geom_sf(aes(fill = `SIMD Quintile`, colour = `SIMD Quintile`, DZ = DataZone)) + scale_fill_viridis_c(&quot;SIMD Quintile&quot;, option = &quot;C&quot;, aesthetics = c(&quot;fill&quot;, &quot;colour&quot;)) + theme_void() plotly::ggplotly(p, tooltip = c(&quot;DZ&quot;, &quot;fill&quot;)) 5.4 {leaflet} Leaflet produces interactive maps, that are set on top of a base tile. The base tile shows the underlying area, making it great for areal unit maps, but even more effective for point maps. There is added functionality in Leaflet that will allow you to add multiple layers to you plot which means that you can have layers show and vanish as needed. Leaflet requires that your spatial information be coded as latitude/longitude, so we implement that using the function st_transform() from the {sf} package as follows: SIMD_map &lt;- st_transform(SIMD_map, 4326) For the purposes of getting started, we will focus on a single layer with an on/off toggle. We always start by calling leaflet(), and then adding our base tile: leaflet() %&gt;% addProviderTiles(&quot;OpenStreetMap.Mapnik&quot;) This looks odd at the moment, but once we add data, the map will automatically focus on the appropriate area. If we just want to add the regions themselves with no data, we can do that directly using the function addPolygons(). the argument popup allows us to specify what displays when we click on a particular region. leaflet(SIMD_map) %&gt;% addProviderTiles(&quot;OpenStreetMap.Mapnik&quot;) %&gt;% addPolygons(popup = ~paste0(&quot;Datazone: &quot;, DataZone)) We can customise the outline and fill using various arguments to addPolygons(). The arguments color and weight control the outlines, and fillColor controls the fill colour. leaflet(SIMD_map) %&gt;% addProviderTiles(&quot;OpenStreetMap.Mapnik&quot;) %&gt;% addPolygons(popup = ~paste0(&quot;Datazone: &quot;, DataZone), color = &quot;black&quot;, weight = 0.5, fillColor = &quot;red&quot;) If we want the fill colour to vary depending on the SIMD value, we have to first create a palette to use. The easiest way to do this is to use the colorNumeric() function for a numeric value (there is also colorFactor() for categorical data): pal &lt;- colorNumeric(&quot;magma&quot;, SIMD_map$simd202_11) Then we use this palette to specify the fill colour within addPolygons(). The opacity has also been increased to make the colours more visible, and the popup is updated to include the SIMD quintile (note that this uses HTML, where &lt;br&gt; denotes new line. We add a legend using addLegend() and specifying the palette (note that we haven’t specified the data within addLegend() so we have to use the dollar notation SIMD_map$202_11). leaflet(SIMD_map) %&gt;% addProviderTiles(&quot;OpenStreetMap.Mapnik&quot;) %&gt;% addPolygons(popup = ~paste0(&quot;Datazone: &quot;, DataZone, &quot;&lt;br&gt;SIMD Quintile: &quot;, simd202_11), color = &quot;black&quot;, weight = 0.5, fillColor = ~pal(simd202_11), fillOpacity = 0.8) %&gt;% addLegend(pal = pal, position = &quot;bottomleft&quot;, values = SIMD_map$simd202_11) Finally, let’s add another layer containing SIMD decile (column simd202_10) plus a toggle to switch between quintile and decile. We need a few things here: An additional palette for the decile values An additional legend for the decile values An additional set of polygons for the decile values Group names set within addPolygons() for each of quintile and decile A control to toggle between the layers We do this by setting up a group within addPolygons(), and then using addLayersControl() to add the switch to the plot. # Process for creating palette is exactly the same, just different column pal_quin &lt;- colorNumeric(&quot;magma&quot;, SIMD_map$simd202_11) pal_dec &lt;- colorNumeric(&quot;magma&quot;, SIMD_map$simd202_10) leaflet(SIMD_map) %&gt;% addProviderTiles(&quot;OpenStreetMap.Mapnik&quot;) %&gt;% # Polygons for quintiles addPolygons(popup = ~paste0(&quot;Datazone: &quot;, DataZone, &quot;&lt;br&gt;SIMD Quintile: &quot;, simd202_11), color = &quot;black&quot;, weight = 0.5, fillColor = ~pal_quin(simd202_11), fillOpacity = 0.8, group = &quot;SIMD Quintile&quot;) %&gt;% # Polygons for deciles addPolygons(popup = ~paste0(&quot;Datazone: &quot;, DataZone, &quot;&lt;br&gt;SIMD Decile: &quot;, simd202_10), color = &quot;black&quot;, weight = 0.5, fillColor = ~pal_dec(simd202_10), fillOpacity = 0.8, group = &quot;SIMD Decile&quot;) %&gt;% addLegend(pal = pal_quin, position = &quot;bottomleft&quot;, values = SIMD_map$simd202_11, group = &quot;SIMD Quintile&quot;, title = &quot;SIMD Quintile&quot;) %&gt;% addLegend(pal = pal_dec, position = &quot;bottomright&quot;, values = SIMD_map$simd202_10, group = &quot;SIMD Decile&quot;, title = &quot;SIMD Decile&quot;) %&gt;% addLayersControl( # Groups will show in order they are set here baseGroups = c(&quot;SIMD Quintile&quot;, &quot;SIMD Decile&quot;), position = &quot;topright&quot;, # set collapsed = FALSE so that controls always displayed options = layersControlOptions(collapsed = FALSE) ) "],["spatial-point-maps-in-leaflet.html", "Chapter 6 Spatial Point Maps in {leaflet}", " Chapter 6 Spatial Point Maps in {leaflet} "],["helpful-resources.html", "Chapter 7 Helpful Resources", " Chapter 7 Helpful Resources "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
